shell->cmdline is filled with cmd line using readline

1) Lexer

- insert_spaces: insert spaces between the tokens (echo>infile becomes echo > infile)

- insert_spaces_quotes(t_mini *shell): insert space after even insert_spaces_quotes
USELESS ? Creates errors

- count_tokens: counts the nb of tokens by splitting with spaces, skipping quotes

- init_lex: will init struct t_lex :

typedef struct s_lex
{
	int				i;
	int				nb_expansions;
	char			*word;
	t_token			token;
	struct s_lex	*next;
}	t_lex;
malloc the linked list thanks to nb_token & initiates the elements of the struct

- assign_word(shell): fills word in lex structure.
  with get_token : big malloc with size of cmdline + 1 for each token. Fills with the token, spliting with spaces.
  Special function to handle spaces between double quote: they should not generate a new token : modified ft_split that doesn't split
  between quotes.


- assign_token : if it is | token pipe, same for < << > >>, if not token WORD.

------------

OK Unclosed quotes à gérer: dans toutes les fonctions de passage/gestion de quote : ajouter fonction ft_strchr de quote de fermeture. N'effectuer ces fonctions que si quopte de fermeture.

fix to do on test"test test" counting 2 tokens instead of 1 -> l erruer vient du fait
que nb token ancienne fonction ne compte pas comme substr quote : refaire nb token
comme substr quote

Fixs :

mallocs de tout cmdline trop grand dans get_token -> réduit aux mallocs nécessaires

Ajout d espace seuleument apres double quote erreur sur 'test'test
