shell->cmdline is filled with cmd line using readline

1) Lexer

- insert_spaces: insert spaces between the tokens (echo>infile becomes echo > infile)

- insert_spaces_quotes(t_mini *shell): insert space after even insert_spaces_quotes
USELESS ? Creates errors

- count_tokens: counts the nb of tokens by splitting with spaces, skipping quotes

- init_lex: will init struct t_lex :

typedef struct s_lex
{
	int				i;
	int				nb_expansions;
	char			*word;
	t_token			token;
	struct s_lex	*next;
}	t_lex;
malloc the linked list thanks to nb_token & initiates the elements of the struct

- assign_word(shell): fills word in lex structure.
  with get_token : big malloc with size of cmdline + 1 for each token. Fills with the token, spliting with spaces, skipping finished quotes.

  ft_quotesplit is ike ft_split with ' ' but it also skips finished quotes, and it doesn't copy the quotes when they are finihed as we
  only need what is inside of them.

  As quotes are deleted by ft_quotesplit, the function keeps the info thar the token was betwen quotes in booleans data->is_bq[i].
  That int* will later be used by fill types to fill type DQUOTE if data->is_bq[i] == 1.


- assign_token : if it is | token pipe, same for < << > >>, if not token WORD.

------------

OK Unclosed quotes à gérer: dans toutes les fonctions de passage/gestion de quote : ajouter fonction ft_strchr de quote de fermeture. N'effectuer ces fonctions que si quopte de fermeture.

fix to do on test"test test" counting 2 tokens instead of 1 -> l erruer vient du fait
que nb token ancienne fonction ne compte pas comme substr quote : refaire nb token
comme substr quote

Fixs :

mallocs de tout cmdline trop grand dans get_token -> réduit aux mallocs nécessaires

Ajout d espace seuleument apres double quote erreur sur 'test'test
